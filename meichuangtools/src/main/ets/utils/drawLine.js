import{Chart,calculateNum,roundRect}from"./charts";class DrawLine extends Chart{constructor(){super()}bindEvent(t,e){this.ctx;const i=this.xAxis.data.length;const s=(this.W-this.cPaddingL-this.cPaddingR)/(i-1);let l=0;let a=t.localX,h=t.localY;if(!this.drawing)if(h>this.cPaddingL+this.cPaddingT&&h<this.H-this.cPaddingL&&a>this.cPaddingL&&a<this.W-this.cPaddingL){for(var o=0;o<i;o++)a>o*s&&(l=o);this.clearGrid(l);var n=[];for(var r,d=0,c=this.animateArr.length;d<c;d++)(r=this.animateArr[d]).hide||n.push({name:r.name,num:r.data[l].num});e(!0,{x:this.animateArr[0].data[l].x,W:this.W,H:this.H},this.xAxis.data[l],n,this.tooltip)}else{this.clearGrid();e(!1)}}clearGrid(t){let e=this;let i;let s=this.ctx;s.translate(0,0);s.restore();s.clearRect(0,0,e.W,e.H);this.drawAxis();this.drawTag();this.drawY();if("number"==typeof t){i=e.animateArr[0].data[t];s.lineWidth=1;s.strokeStyle="hsla(0,0%,70%,1)";s.moveTo(i.x,-(e.H-e.cPaddingT-e.cPaddingB));s.lineTo(i.x,0);s.stroke()}for(let l,a=0,h=e.animateArr.length;a<h;a++){l=e.animateArr[a];if(l.hide)continue;const{lineStyle:h,itemStyle:o,color:n,label:r}=l;const{color:d,width:c}=h;e.setCtxStyle({strokeStyle:d||n,lineWidth:c});s.beginPath();for(let t,e=0,i=l.data.length;e<i;e++){t=l.data[e];s[0==e?"moveTo":"lineTo"](t.x,-t.h)}s.stroke();const{symbol:f,symbolSize:x,symbolColor:g,borderWidth:m,borderType:y,borderColor:T}=o;const{show:P,color:S,fontWeight:u,fontFamily:A,fontSize:p}=r;for(let e=0,a=l.data.length;e<a;e++){i=l.data[e];if("solidCircle"===f){s.beginPath();s.arc(i.x,-i.h,x*(t===e?2:1),0,2*Math.PI,!1);s.fillStyle=g||n;s.fill()}if(P){s.font=`${u} ${p}px ${A}`;s.fillStyle=S;const t=String(i.num);const e=s.measureText(t).width;const l=s.measureText(t).height;s.fillText(t,i.x-e/2,-i.h-l/2)}}}s.restore()}animate(){let t=this;let e=this.ctx;let i=t.W-2*t.cPaddingL;let s;let l=0;let a=0;let h=0;let o=!0;t.drawing=!0;!function n(){o=!0;e.clearRect(0,t.cPaddingL+t.cPaddingT-5,t.W,t.H-t.cPaddingL-t.cPaddingR-t.cPaddingT+4);e.save();for(let n,r=0,d=t.animateArr.length;r<d;r++){n=t.animateArr[r];if(n.hide)continue;n.isStop=!0;e.beginPath();const{lineStyle:d,itemStyle:c,color:f,label:x}=n;const{color:g,width:m}=d;t.setCtxStyle({strokeStyle:g||f,lineWidth:m});if(n.create){n.xl+=20;a=n.xl;for(let t,i=0,l=n.data.length;i<l;i++){t=n.data[i];s=n.data[i-1];if(0==i)e.moveTo(t.x,-t.h);else if(a>=t.x)e.lineTo(t.x,-t.h);else if(a<t.x){h=s.h+(a-s.x)/(t.x-s.x)*(t.h-s.h);e.lineTo(a,-h);break}}e.stroke();const{symbol:t,symbolSize:l,symbolColor:o,borderWidth:r,borderType:d,borderColor:g}=c;const{show:m,color:y,fontWeight:T,fontFamily:P,fontSize:S}=x;for(let i,s=0,h=n.data.length;s<h;s++){i=n.data[s];if(a>=i.x){i.y=i.p=i.h;if("solidCircle"===t){e.beginPath();e.arc(i.x,-i.h,l,0,2*Math.PI,!1);e.fillStyle=o||f;e.fill()}if(m){e.font=`${T} ${S}px ${P}`;e.fillStyle=y;const t=String(i.num);const s=e.measureText(t).width;const l=e.measureText(t).height;e.fillText(t,i.x-s/2,-i.h-l/2)}}}n.xl<i&&(n.isStop=!1)}else{for(let t,i=0,s=n.data.length;i<s;i++){t=n.data[i];if(t.p>t.h){l=t.y-4;l<t.h&&(t.y=t.p=t.h)}else{l=t.y+4;l>t.h&&(t.y=t.p=t.h)}if(t.p!=t.h){t.y=l;n.isStop=!1}e[0==i?"moveTo":"lineTo"](t.x,-t.y)}e.stroke();for(let t,i=0,s=n.data.length;i<s;i++){t=n.data[i];e.beginPath();e.arc(t.x,-t.y,2,0,2*Math.PI,!1);e.stroke();e.fill()}}n.isStop||(o=!1)}e.restore();o?t.drawing=!1:setTimeout((()=>{n()}),50)}()}create(){this.drawAxis();this.initData();this.drawTag();this.drawY();this.animate()}initData(){let t=this;let e=this.xAxis.data.length;let i=(this.W-2*this.cPaddingL)/(e-1);let s=this.H-2*this.cPaddingL-this.cPaddingT;let l=0;let a=0;let h;let o;let n=[];if(this.series.length){for(let t=0;t<this.series.length;t++){h=this.series[t];if(h.data&&h.data.length){h.color||(h.color=this.color[t]);h.name=h.name||"unnamed";if(!h.hide){0;n=n.concat(h.data.slice(0,e))}}else this.series.splice(t--,1)}this.info=calculateNum(n);l=this.info.min;a=this.info.max;for(let n=0;n<this.series.length;n++){h=this.series[n];if(this.animateArr[n]){if(t.animateArr[n].hide&&!h.hide){t.animateArr[n].create=!0;t.animateArr[n].xl=0}else t.animateArr[n].create=!1;t.animateArr[n].hide=h.hide;h.data.slice(0,e).forEach(((e,i)=>{t.animateArr[n].data[i].h=Math.floor((e-l)/(a-l)*s+2)}))}else{o=Object.assign({},Object.assign(Object.assign({i:n,isStop:!0,xl:0,create:!0},h),{hide:!!h.hide,name:h.name,color:h.color,data:[]}));h.data.slice(0,e).forEach(((t,e)=>{o.data.push({num:t,h:Math.floor((t-l)/(a-l)*s+2),p:0,x:Math.round(i*e),y:0})}));this.animateArr.push(o)}}}}drawTag(){let t=0;let e;let i=this.ctx;for(let s=0;s<this.series.length;s++){e=this.series[s];i.save();i.translate(this.cPaddingL+this.W/4,this.cPaddingT/2);this.legend.push({hide:e.hide||!1,name:e.name,color:e.color,x:this.cPaddingL+this.W/4+90*s+t,y:this.cPaddingT+40,w:20,h:10,r:2});i.font="400 18px sans-serif";i.textAlign="left";i.fillStyle=e.color;i.strokeStyle=e.color;roundRect(i,45*s+t,0,20,10,2);i.globalAlpha=e.hide?.3:1;i.fill();i.fillText(e.name,45*s+t+25,7);t+=i.measureText(e.name).width;i.restore()}}drawAxis(){let t=this.ctx;let e=this.W;let i=this.H;let s=this.cPaddingL;let l=this.cPaddingR;this.cPaddingT;let a=0;let h=0;t.clearRect(0,0,e,i);t.save();t.translate(s,i-s);const{axisTick:o,splitLine:n,axisLine:r={},axisLabel:d,data:c}=this.xAxis;const{show:f=!0}=r;if(f){const{color:i="#333",width:a=1}=r.lineStyle;this.setCtxStyle({strokeStyle:i,lineWidth:a});t.beginPath();t.moveTo(0,0);t.lineTo(e-s-l,0);t.stroke()}if(this.xAxis&&(a=c.length)){h=(e-s-l)/(a-1);c.forEach(((e,i)=>{let s=h*(i+1);if(o.show){const{color:e,width:i}=o.lineStyle;t.beginPath();this.setCtxStyle({strokeStyle:e,lineWidth:i});t.moveTo(s,0);t.lineTo(s,o.length);t.stroke()}const{color:l,fontWeight:a,fontSize:n,fontFamily:r}=d;this.ctx.font=`${a} ${n}px ${r}`;this.ctx.fillStyle=l;const c=this.ctx.measureText(e).width;t.fillText(e,s-h-c/2,12)}))}t.restore()}drawY(){const{axisTick:t,splitLine:e,axisLine:i,axisLabel:s,nameTextStyle:l}=this.yAxis;let a=this.ctx;let h=0;if(this.yAxis&&this.yAxis.name){const{color:t,fontWeight:e,fontSize:i,fontFamily:s}=l;this.ctx.fillStyle=t;this.ctx.font=`${e} ${i}px ${s}`;h=this.ctx.measureText(this.yAxis.name).height;const o=this.ctx.measureText(this.yAxis.name).width;a.fillText(this.yAxis.name,this.cPaddingL-o/2,this.cPaddingT)}let o=this.W-this.cPaddingL-this.cPaddingR;let n=this.H-this.cPaddingL-this.cPaddingT-h;let r=this.info.num;let d=n/r;a.save();a.translate(this.cPaddingL,this.H-this.cPaddingL);for(let i=0;i<=r;i++){if(t.show){const{color:e,width:s}=t.lineStyle;a.beginPath();this.setCtxStyle({strokeStyle:e,lineWidth:s});a.moveTo(-5,-Math.floor(d*i));a.lineTo(0,-Math.floor(d*i));a.stroke()}if(i>0&&e.show){const{color:t,width:s}=e.lineStyle;this.setCtxStyle({strokeStyle:t,lineWidth:s});a.beginPath();a.moveTo(0,-Math.floor(d*i));a.lineTo(o,-Math.floor(d*i));a.stroke()}const{color:l,fontWeight:h,fontSize:n,fontFamily:r}=s;this.ctx.fillStyle=l;this.ctx.font=`${h} ${n}px ${r}`;a.textAlign="right";let c=Math.floor(this.info.step*i+this.info.min);let f=this.yAxis.formatter?this.yAxis.formatter.replace("{value}",c):String(c);const x=this.ctx.measureText(f).height;a.fillText(f,-8,-d*i+x/2)}a.restore();if(i.show){const{color:t,width:e}=i.lineStyle;this.setCtxStyle({strokeStyle:t,lineWidth:e});a.save();a.beginPath();a.translate(this.cPaddingL,this.H-this.cPaddingL);a.moveTo(0,0);a.lineTo(0,this.cPaddingL+this.cPaddingT-this.H+h);a.stroke()}}}export default DrawLine;